---
layout: mypost
title: buuoj_re_crackrtfs
categories: [buuoj]
---

# 下载老样子丢进查壳软件中查看是否有壳
![查壳](1.png)

# 发现软件无壳且是32位，丢入ida查看一下主要逻辑
![逻辑1](2.jpg)
![逻辑2](3.jpg)

# 简单观察一下逻辑，一共需要输入两次密码，在第一次输入密码(6位)，将"@DBApp"缝合在第一次密码之后
# 对缝合后密码进行一个操作(猜测是某种加密)，然后将得到的字符串与"6E32D0943418C2C33385BC35A1470250DD8923A9"做比较
![逻辑3](4.jpg)

# 紧接着输入第二次密码，将缝合后的第一次密码连接在第二次密码之后进行一个操作，然后将得到的字符串与"27019e688a4e62a649fd99cadaafdb4e"作比较
![逻辑3](5.jpg)

# 那么这个程序的着重点自然在两个某种操作之上，首先我们来看看第一个
![逻辑3](6.jpg)

# 一上来肯定都看不懂，于是逐个去搜索这些系统调用函数的用法
[函数用法](https://docs.microsoft.com/zh-cn/windows/win32/api/wincrypt)
# 首先这个CryptAcquireContextA函数
![逻辑3](7.png)
# 主要作用是连接CSP，获得指定CSP的密钥容器的句柄，大概意思就是创建一个windows系统加密的环境
# 其次主要起作用的是下面那个函数CryptCreateHash
![逻辑3](8.jpg)

# 功能当然在微软的网站上也能找到
![逻辑3](9.jpg)
## 其中的第二个参数，也就是图中的x8004u是加密种类参数，决定了对字符串使用的加密种类
![逻辑3](10.jpg)

# 查询到第一次操作就是对一个六位密码进行一次SHA1加密
# 马不停蹄去看第二次操作，也是一个hash加密，对加密种类参数查询之后发现是MD5加密
# 也就是说"27019e688a4e62a649fd99cadaafdb4e"这个字符串是MD5加密之后的结果，那我们可以尝试解密
![逻辑3](11.jpg)

# 我们看到末尾是"@DBApp"与逻辑一致，那前面的12位则分别是第二次密码(6位)与第一次密码(6位)
# 再次打开exe，依次输入两次的密码发现文件夹中多生成了一个rtf文件
## 得到Flag{N0_M0re_Free_Bugs}